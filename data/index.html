<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ESP32 Env Controller</title>
        <!-- <link rel="stylesheet" href="style.css"> -->
         <style>
            /* src/data/style.css */
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 0;
                background-color: #eef1f5;
                color: #333;
                line-height: 1.5;
            }

            .container {
                max-width: 1100px;
                margin: 10px auto;
                padding: 0 15px; /* Add padding for smaller screens */
            }

            /* --- Navbar Styles --- */
            .navbar {
                background-color: #343a40;
                color: #fff;
                padding: 10px 25px;
                margin-bottom: 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-radius: 0 0 8px 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .navbar-brand {
                font-size: 1.4em;
                font-weight: bold;
            }
            .navbar-ip {
                font-size: 0.9em;
                color: #adb5bd;
            }

            /* --- Tab Styles --- */
            .tab {
                overflow: hidden;
                border-bottom: 1px solid #ccc;
                background-color: #f8f9fa;
                margin-bottom: 15px;
                border-radius: 5px 5px 0 0;
            }
            .tab button {
                background-color: inherit;
                float: left;
                border: none;
                outline: none;
                cursor: pointer;
                padding: 12px 18px;
                transition: background-color 0.3s;
                font-size: 1.1em;
                border-right: 1px solid #ddd;
                color: gray;
                display: flex; /* Align icon and text */
                align-items: center;
                gap: 6px; /* Space between icon and text */
            }
            .tab button:last-child { border-right: none; }
            .tab button:hover { background-color: #e9ecef; }
            .tab button.active {
                background-color: #fff;
                border-bottom: 2px solid #007bff;
                color: #0056b3;
                font-weight: bold;
            }
            .tab button.hidden {
                display: none;
            }
            
            .tabcontent {
                display: none;
                padding: 10px 0;
                animation: fadeEffect 0.5s;
            }
            @keyframes fadeEffect { from {opacity: 0;} to {opacity: 1;} }

            /* Timer Tab Specific Styles */
            .timer-info {
                margin-bottom: 15px;
            }
            .timer-info .status-item { /* Reuse status-item style */
                border-bottom: none; /* Remove border within this group */
                padding: 3px 0;
            }

            .table-container {
                max-height: 200px; /* Limit height and add scroll if many entries */
                overflow-y: auto;
                border: 1px solid #eee;
                margin-top: 10px;
            }

            #timer-list-table {
                width: 100%;
                border-collapse: collapse;
                font-size: 0.95em;
            }

            #timer-list-table th, #timer-list-table td {
                border: 1px solid #ddd;
                padding: 6px 10px;
                text-align: center;
            }
            #timer-list-table button { /* Make buttons in table smaller */
                padding: 4px 8px;
                font-size: 0.8em;
            }
            #timer-list-table th:last-child, #timer-list-table td:last-child { width: 80px; }
            #timer-list-table th {
                background-color: #f2f2f2;
                font-weight: bold;
            }

            #timer-list-table tbody tr:nth-child(even) {
                background-color: #f9f9f9;
            }
            #timer-list-table tbody tr:hover {
                background-color: #f1f1f1;
            }
            .timer-info { margin-bottom: 15px; }
            .timer-info .status-item { border-bottom: none; padding: 3px 0; }
            .table-container { max-height: 200px; overflow-y: auto; border: 1px solid #eee; margin-top: 10px; }
            #timer-list-table { width: 100%; border-collapse: collapse; font-size: 0.95em; }
            #timer-list-table th, #timer-list-table td { border: 1px solid #ddd; padding: 6px 10px; text-align: center; }
            #timer-list-table th { background-color: #f2f2f2; font-weight: bold; }
            #timer-list-table tbody tr:nth-child(even) { background-color: #f9f9f9; }
            #timer-list-table tbody tr:hover { background-color: #f1f1f1; }
            .card > button[onclick="syncTimeNow()"] { display: block; margin: 15px auto 0 auto; background-color: #17a2b8; }
            .card > button[onclick="syncTimeNow()"]:hover { background-color: #138496; }
            .status-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 25px; }
            /* --- Card Styles --- */
            .card {
                background: #fff;
                padding: 25px;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                margin-bottom: 20px;
            }
            .card h2 {
                margin-top: 0;
                font-size: 1.4em;
                color: #0056b3;
                border-bottom: 1px solid #eee;
                padding-bottom: 10px;
                margin-bottom: 20px;
            }
            .card > button[onclick="syncTimeNow()"] {
                display: block;
                margin: 15px auto 0 auto;
                background-color: #17a2b8; /* Info color */
            }
            .card > button[onclick="syncTimeNow()"]:hover {
                background-color: #138496;
            }
            /* --- Gauge Styles --- */
            .gauges {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
                gap: 20px;
                text-align: center;
            }
            .gauge-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 10px;
            }
            .gauge-container div { margin-top: 8px; font-size: 1em; color: #555; }
            .gauge-value {
                font-weight: bold; font-size: 1.2em; color: #333;
                margin-top: -8px; margin-bottom: 5px; min-height: 1.2em; display: inline-block;
            }
            canvas.gauge {
                width: 150px !important; height: 75px !important;
                display: block; margin: 0 auto 5px auto;
            }

            /* --- Status and Settings Styles --- */
            .status-item, .setting {
                font-size: 1.05em;
                display: flex; flex-wrap: wrap; justify-content: space-between;
                align-items: center; padding: 8px 0;
                border-bottom: 1px solid #f0f0f0;
            }
            .setting:last-of-type { border-bottom: none; }
            .status-item strong, .setting strong {
                color: #333; margin-right: 15px; flex-basis: 150px; flex-shrink: 0;
            }
            .setting div { display: flex; align-items: center; flex-wrap: wrap; gap: 10px; }
            .value { font-weight: bold; color: #28a745; text-align: right; margin-left: auto; }
            .value.off { color: #dc3545; }
            .value.warn { color: #ffc107; }

            /* Separated Mode Line */
            .mode-line { font-size: 1.15em; padding-bottom: 12px; border-bottom: none; }
            hr.status-divider { border: none; border-top: 1px solid #eee; margin: 5px 0 15px 0; }
            .status-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 25px; }

            /* Form Elements */
            input[type=number], select {
                width: 70px; padding: 6px 8px; border: 1px solid #ced4da;
                border-radius: 4px; font-size: 1em;
            }
            select { width: auto; }
            button {
                padding: 8px 18px; font-size: 1em; border: none; border-radius: 5px;
                cursor: pointer; background-color: #007bff; color: white;
                transition: background-color 0.2s ease;
                display: inline-flex; /* Align icon and text */
                align-items: center;
                gap: 6px; /* Space between icon and text */
            }
            button:hover { background-color: #0056b3; }
            .card > button { display: block; margin: 20px auto 0 auto; } /* Center Save button */

            /* Error Message */
            #error-msg {
                color: #dc3545; text-align: center; margin-top: 20px; font-weight: bold;
                padding: 10px; background-color: #f8d7da; border: 1px solid #f5c6cb;
                border-radius: 5px; display: none;
            }
            #error-msg:not(:empty) { display: block; }

            /* Responsiveness */
            @media (max-width: 768px) {
                .navbar { flex-direction: column; gap: 5px; }
                .status-grid { grid-template-columns: 1fr; gap: 5px;}
                .setting { flex-direction: column; align-items: flex-start; }
                .setting strong { margin-bottom: 5px; }
                .setting div { width: 100%; justify-content: flex-start; } /* Align controls left on small screens */
                .card > button { width: 90%; } /* Make save button wider */
            }
            button i.fas { margin-right: 6px; }
            .tab button i.fas { margin-right: 6px; }
         </style>
    </head>
    <body>
        <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink">
            <defs>
                <symbol id="icon-dashboard" viewBox="0 0 16 16"><path d="M11 2a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v12h-4V2zm-6 8a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v4h-4V10zm-6-4a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v8H0V6z"/></symbol>
                <symbol id="icon-settings" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></symbol>
                <symbol id="icon-timer" viewBox="0 0 16 16"><path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/><path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/></symbol>
                <symbol id="icon-sync" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></symbol>
                <symbol id="icon-save" viewBox="0 0 16 16"><path d="M9.293 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.707A1 1 0 0 0 13.707 4L10 .293A1 1 0 0 0 9.293 0zM9.5 3.5v-2l3 3h-2a1 1 0 0 1-1-1zM6.354 9.854a.5.5 0 0 1-.708-.708l-1.5-1.5a.5.5 0 0 1 0-.708l1.5-1.5a.5.5 0 1 1 .708.708L5.207 7.5H10a.5.5 0 0 1 0 1H5.207l1.147 1.146a.5.5 0 0 1 0 .708z"/></symbol>
                <symbol id="icon-reset" viewBox="0 0 16 16"><path d="M8 3a.5.5 0 0 1 .5.5v2.5H11a.5.5 0 0 1 0 1H8.5V11a.5.5 0 0 1-1 0V7.5H5a.5.5 0 0 1 0-1h2.5V4a.5.5 0 0 1 .5-.5z"/><path d="M8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1zM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8z"/></symbol>
            </defs>
        </svg>
        <nav class="navbar">
            <div class="navbar-brand">Environmental Controller</div>
            <div class="navbar-ip" id="nav-ip">IP: Loading...</div>
        </nav>

        <div class="container">
            <div class="tab">
                <button class="tablinks active" onclick="openTab(event, 'Dashboard')">
                    <svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><use xlink:href="#icon-dashboard"></use></svg>
                    Dashboard
                </button>
                <button class="tablinks" onclick="openTab(event, 'Settings')">
                     <svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><use xlink:href="#icon-settings"></use></svg>
                    Settings
                </button>
                <button class="tablinks hidden" id="timer-tab-button" onclick="openTab(event, 'Timer')">
                     <svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><use xlink:href="#icon-timer"></use></svg>
                     Timer
                </button>
            </div>
            

            <div id="Dashboard" class="tabcontent" style="display: block;">
                <div class="card">
                    <h2>Live Readings</h2>
                    <div class="gauges">
                        <div class="gauge-container">
                            <canvas id="gauge-temp" class="gauge"></canvas>
                            <span id="gauge-temp-val"
                                class="gauge-value">--</span>
                            <div>Temperature (&deg;C)</div>
                        </div>
                        <div class="gauge-container">
                            <canvas id="gauge-hum" class="gauge"></canvas>
                            <span id="gauge-hum-val"
                                class="gauge-value">--</span>
                            <div>Humidity (%)</div>
                        </div>
                        <div class="gauge-container">
                            <canvas id="gauge-gas" class="gauge"></canvas>
                            <span id="gauge-gas-val"
                                class="gauge-value">--</span>
                            <div>Gas Level</div>
                        </div>
                        <div class="gauge-container">
                            <canvas id="gauge-soil" class="gauge"></canvas>
                            <span id="gauge-soil-val"
                                class="gauge-value">--</span>
                            <div>Soil Moisture (%)</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2>System Status</h2>
                    <div class="status-item mode-line">
                        <strong>Mode:</strong> <span id="mode"
                            class="value">--</span>
                    </div>
                    <hr class="status-divider">
                    <div class="status-grid">
                        <div class="status-item"><strong>Relay 1
                                (Heat):</strong> <span id="r1"
                                class="value off">--</span></div>
                        <div class="status-item"><strong>Relay 2
                                (Heat):</strong> <span id="r2"
                                class="value off">--</span></div>
                        <div class="status-item"><strong>Relay 3
                                (Dehum):</strong> <span id="r3"
                                class="value off">--</span></div>
                        <div class="status-item"><strong>Relay 4
                                (Mist):</strong> <span id="r4"
                                class="value off">--</span></div>
                    </div>
                </div>
            </div>

            <div id="Settings" class="tabcontent">
                <div class="card">
                    <h2>Settings</h2>
                    <div class="setting">
                        <strong>Mode Control:</strong>
                        <div>
                            <select id="mode-select">
                                <option value="0">AUTO</option>
                                <option value="1">OFF</option>
                                <option value="2">ON</option>
                                <option value="3">HALF</option>
                                <option value="4">TIMER</option>
                            </select>
                            <button onclick="setMode()">Set Mode</button>
                        </div>
                    </div>
                    <div class="setting">
                        <strong>Min Temp (&deg;C):</strong>
                        <div>
                            <span id="min-temp-disp" class="value">--</span>
                            <input type="number" id="min-temp-input" step="1">
                        </div>
                    </div>
                    <div class="setting">
                        <strong>Max Temp (&deg;C):</strong>
                        <div>
                            <span id="max-temp-disp" class="value">--</span>
                            <input type="number" id="max-temp-input" step="1">
                        </div>
                    </div>
                    <div class="setting">
                        <strong>Switch Delay (s):</strong>
                        <div>
                            <span id="delay-disp" class="value">--</span>
                            <input type="number" id="delay-input" step="1"
                                min="1" max="300">
                        </div>
                    </div>
                    <div class="setting">
                        <strong>Humidity Limit (%):</strong>
                        <div>
                            <span id="hum-limit-disp" class="value">--</span>
                            <input type="number" id="hum-limit-input" step="1"
                                min="0" max="100">
                        </div>
                    </div>
                    <div class="setting">
                        <strong>Gas Limit (Raw):</strong>
                        <div>
                            <span id="gas-limit-disp" class="value">--</span>
                            <input type="number" id="gas-limit-input" step="50"
                                min="0" max="4095">
                        </div>
                    </div>
                    <button onclick="saveAllSettings()">
                        <svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><use xlink:href="#icon-save"></use></svg>
                        Save All Settings
                    </button>
                </div>
            </div>
            <div id="Timer" class="tabcontent">
                <div class="card">
                    <h2>Timer Status & Schedule</h2>
                    <div class="timer-info">
                         <div class="status-item"><strong>Current Time:</strong> <span id="timer-current-time" class="value">--:--:--</span></div>
                         <div class="status-item"><strong>Timer Start Date:</strong> <span id="timer-start-date" class="value">--/--/--</span></div>
                         <div class="status-item"><strong>Days Elapsed:</strong> <span id="timer-days-passed" class="value">--</span></div>
                    </div>
                    <button onclick="syncTimeNow()" style="margin-top: 10px;">
                        <svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><use xlink:href="#icon-sync"></use></svg>
                        Sync RTC with Network Time
                    </button>
                    <hr class="status-divider">
                    <h3>Timer Schedule (Min/Max Temp)</h3>
                    <div class="table-container">
                        <table id="timer-list-table">
                            <thead>
                                <tr>
                                    <th>Day Offset</th>
                                    <th>Min Temp (&deg;C)</th>
                                    <th>Max Temp (&deg;C)</th>
                                    <th>Action</th> </tr>
                            </thead>
                            <tbody>
                                <tr><td colspan="4">Loading schedule...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div id="error-msg"></div>
        </div>
        <!-- For the GAUGE -->
        <script> 
            (function() {
            var t, i, e, s, n, o, a, h, r, l, c, p, u, d, g = [].slice,
                m = {}.hasOwnProperty,
                f = function(t, i) {
                    for (var e in i) m.call(i, e) && (t[e] = i[e]);

                    function s() {
                        this.constructor = t
                    }
                    return s.prototype = i.prototype, t.prototype = new s, t.__super__ = i.prototype, t
                },
                x = [].indexOf || function(t) {
                    for (var i = 0, e = this.length; i < e; i++)
                        if (i in this && this[i] === t) return i;
                    return -1
                };
            ! function() {
                var t, i, e, s, n, o, a;
                for (e = 0, n = (a = ["ms", "moz", "webkit", "o"]).length; e < n && (o = a[e], !window.requestAnimationFrame); e++) window.requestAnimationFrame = window[o + "RequestAnimationFrame"], window.cancelAnimationFrame = window[o + "CancelAnimationFrame"] || window[o + "CancelRequestAnimationFrame"];
                t = null, s = 0, i = {}, window.requestAnimationFrame ? window.cancelAnimationFrame || (t = window.requestAnimationFrame, window.requestAnimationFrame = function(e, n) {
                    var o;
                    return o = ++s, t((function() {
                        if (!i[o]) return e()
                    }), n), o
                }, window.cancelAnimationFrame = function(t) {
                    return i[t] = !0
                }) : (window.requestAnimationFrame = function(t, i) {
                    var e, s, n, o;
                    return e = (new Date).getTime(), o = Math.max(0, 16 - (e - n)), s = window.setTimeout((function() {
                        return t(e + o)
                    }), o), n = e + o, s
                }, window.cancelAnimationFrame = function(t) {
                    return clearTimeout(t)
                })
            }(), d = function(t) {
                    var i, e;
                    for (t -= 3600 * (i = Math.floor(t / 3600)) + 60 * (e = Math.floor((t - 3600 * i) / 60)), t += "", e += ""; e.length < 2;) e = "0" + e;
                    for (; t.length < 2;) t = "0" + t;
                    return (i = i ? i + ":" : "") + e + ":" + t
                }, p = function() {
                    var t, i, e;
                    return e = (i = 1 <= arguments.length ? g.call(arguments, 0) : [])[0], t = i[1], l(e.toFixed(t))
                }, u = function(t, i) {
                    var e, s, n;
                    for (e in s = {}, t) m.call(t, e) && (n = t[e], s[e] = n);
                    for (e in i) m.call(i, e) && (n = i[e], s[e] = n);
                    return s
                }, l = function(t) {
                    var i, e, s, n;
                    for (s = (e = (t += "").split("."))[0], n = "", e.length > 1 && (n = "." + e[1]), i = /(\d+)(\d{3})/; i.test(s);) s = s.replace(i, "$1,$2");
                    return s + n
                }, c = function(t) {
                    return "#" === t.charAt(0) ? t.substring(1, 7) : t
                }, s = function(t) {
                    function i() {
                        return i.__super__.constructor.apply(this, arguments)
                    }
                    return f(i, t), i.prototype.displayScale = 1, i.prototype.forceUpdate = !0, i.prototype.setTextField = function(t, i) {
                        return this.textField = t instanceof h ? t : new h(t, i)
                    }, i.prototype.setMinValue = function(t, i) {
                        var e, s, n, o, a;
                        if (this.minValue = t, null == i && (i = !0), i) {
                            for (this.displayedValue = this.minValue, a = [], s = 0, n = (o = this.gp || []).length; s < n; s++) e = o[s], a.push(e.displayedValue = this.minValue);
                            return a
                        }
                    }, i.prototype.setOptions = function(t) {
                        return null == t && (t = null), this.options = u(this.options, t), this.textField && (this.textField.el.style.fontSize = t.fontSize + "px"), this.options.angle > .5 && (this.options.angle = .5), this.configDisplayScale(), this
                    }, i.prototype.configDisplayScale = function() {
                        var t, i, e, s, n;
                        return s = this.displayScale, !1 === this.options.highDpiSupport ? delete this.displayScale : (i = window.devicePixelRatio || 1, t = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1, this.displayScale = i / t), this.displayScale !== s && (n = this.canvas.G__width || this.canvas.width, e = this.canvas.G__height || this.canvas.height, this.canvas.width = n * this.displayScale, this.canvas.height = e * this.displayScale, this.canvas.style.width = n + "px", this.canvas.style.height = e + "px", this.canvas.G__width = n, this.canvas.G__height = e), this
                    }, i.prototype.parseValue = function(t) {
                        return t = parseFloat(t) || Number(t), isFinite(t) ? t : 0
                    }, i
                }(r = function() {
                    function t(t, e) {
                        null == t && (t = !0), this.clear = null == e || e, t && i.add(this)
                    }
                    return t.prototype.animationSpeed = 32, t.prototype.update = function(t) {
                        var i;
                        return null == t && (t = !1), !(!t && this.displayedValue === this.value) && (this.ctx && this.clear && this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), i = this.value - this.displayedValue, Math.abs(i / this.animationSpeed) <= .001 ? this.displayedValue = this.value : this.displayedValue = this.displayedValue + i / this.animationSpeed, this.render(), !0)
                    }, t
                }()), h = function() {
                    function t(t, i) {
                        this.el = t, this.fractionDigits = i
                    }
                    return t.prototype.render = function(t) {
                        return this.el.innerHTML = p(t.displayedValue, this.fractionDigits)
                    }, t
                }(), t = function(t) {
                    function i(t, e) {
                        if (this.elem = t, this.text = null != e && e, i.__super__.constructor.call(this), void 0 === this.elem) throw new Error("The element isn't defined.");
                        this.value = 1 * this.elem.innerHTML, this.text && (this.value = 0)
                    }
                    return f(i, t), i.prototype.displayedValue = 0, i.prototype.value = 0, i.prototype.setVal = function(t) {
                        return this.value = 1 * t
                    }, i.prototype.render = function() {
                        var t;
                        return t = this.text ? d(this.displayedValue.toFixed(0)) : l(p(this.displayedValue)), this.elem.innerHTML = t
                    }, i
                }(r), a = function(t) {
                    function i(t) {
                        if (this.gauge = t, void 0 === this.gauge) throw new Error("The element isn't defined.");
                        this.ctx = this.gauge.ctx, this.canvas = this.gauge.canvas, i.__super__.constructor.call(this, !1, !1), this.setOptions()
                    }
                    return f(i, t), i.prototype.displayedValue = 0, i.prototype.value = 0, i.prototype.options = {
                        strokeWidth: .035,
                        length: .1,
                        color: "#000000",
                        iconPath: null,
                        iconScale: 1,
                        iconAngle: 0
                    }, i.prototype.img = null, i.prototype.setOptions = function(t) {
                        if (null == t && (t = null), this.options = u(this.options, t), this.length = 2 * this.gauge.radius * this.gauge.options.radiusScale * this.options.length, this.strokeWidth = this.canvas.height * this.options.strokeWidth, this.maxValue = this.gauge.maxValue, this.minValue = this.gauge.minValue, this.animationSpeed = this.gauge.animationSpeed, this.options.angle = this.gauge.options.angle, this.options.iconPath) return this.img = new Image, this.img.src = this.options.iconPath
                    }, i.prototype.render = function() {
                        var t, i, e, s, n, o, a, h, r;
                        if (t = this.gauge.getAngle.call(this, this.displayedValue), h = Math.round(this.length * Math.cos(t)), r = Math.round(this.length * Math.sin(t)), o = Math.round(this.strokeWidth * Math.cos(t - Math.PI / 2)), a = Math.round(this.strokeWidth * Math.sin(t - Math.PI / 2)), i = Math.round(this.strokeWidth * Math.cos(t + Math.PI / 2)), e = Math.round(this.strokeWidth * Math.sin(t + Math.PI / 2)), this.ctx.beginPath(), this.ctx.fillStyle = this.options.color, this.ctx.arc(0, 0, this.strokeWidth, 0, 2 * Math.PI, !1), this.ctx.fill(), this.ctx.beginPath(), this.ctx.moveTo(o, a), this.ctx.lineTo(h, r), this.ctx.lineTo(i, e), this.ctx.fill(), this.img) return s = Math.round(this.img.width * this.options.iconScale), n = Math.round(this.img.height * this.options.iconScale), this.ctx.save(), this.ctx.translate(h, r), this.ctx.rotate(t + Math.PI / 180 * (90 + this.options.iconAngle)), this.ctx.drawImage(this.img, -s / 2, -n / 2, s, n), this.ctx.restore()
                    }, i
                }(r),
                function() {
                    function t(t) {
                        this.elem = t
                    }
                    t.prototype.updateValues = function(t) {
                        return this.value = t[0], this.maxValue = t[1], this.avgValue = t[2], this.render()
                    }, t.prototype.render = function() {
                        var t, i;
                        return this.textField && this.textField.text(p(this.value)), 0 === this.maxValue && (this.maxValue = 2 * this.avgValue), i = this.value / this.maxValue * 100, t = this.avgValue / this.maxValue * 100, $(".bar-value", this.elem).css({
                            width: i + "%"
                        }), $(".typical-value", this.elem).css({
                            width: t + "%"
                        })
                    }
                }(), o = function(t) {
                    function e(t) {
                        var i, s;
                        this.canvas = t, e.__super__.constructor.call(this), this.percentColors = null, "undefined" != typeof G_vmlCanvasManager && (this.canvas = window.G_vmlCanvasManager.initElement(this.canvas)), this.ctx = this.canvas.getContext("2d"), i = this.canvas.clientHeight, s = this.canvas.clientWidth, this.canvas.height = i, this.canvas.width = s, this.gp = [new a(this)], this.setOptions()
                    }
                    return f(e, t), e.prototype.elem = null, e.prototype.value = [20], e.prototype.maxValue = 80, e.prototype.minValue = 0, e.prototype.displayedAngle = 0, e.prototype.displayedValue = 0, e.prototype.lineWidth = 40, e.prototype.paddingTop = .1, e.prototype.paddingBottom = .1, e.prototype.percentColors = null, e.prototype.options = {
                        colorStart: "#6fadcf",
                        colorStop: void 0,
                        gradientType: 0,
                        strokeColor: "#e0e0e0",
                        pointer: {
                            length: .8,
                            strokeWidth: .035,
                            iconScale: 1
                        },
                        angle: .15,
                        lineWidth: .44,
                        radiusScale: 1,
                        fontSize: 40,
                        limitMax: !1,
                        limitMin: !1
                    }, e.prototype.setOptions = function(t) {
                        var i, s, n, o, a;
                        for (null == t && (t = null), e.__super__.setOptions.call(this, t), this.configPercentColors(), this.extraPadding = 0, this.options.angle < 0 && (o = Math.PI * (1 + this.options.angle), this.extraPadding = Math.sin(o)), this.availableHeight = this.canvas.height * (1 - this.paddingTop - this.paddingBottom), this.lineWidth = this.availableHeight * this.options.lineWidth, this.radius = (this.availableHeight - this.lineWidth / 2) / (1 + this.extraPadding), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), s = 0, n = (a = this.gp).length; s < n; s++)(i = a[s]).setOptions(this.options.pointer), i.render();
                        return this.render(), this
                    }, e.prototype.configPercentColors = function() {
                        var t, i, e, s, n, o, a;
                        if (this.percentColors = null, void 0 !== this.options.percentColors) {
                            for (this.percentColors = new Array, o = [], e = s = 0, n = this.options.percentColors.length - 1; 0 <= n ? s <= n : s >= n; e = 0 <= n ? ++s : --s) a = parseInt(c(this.options.percentColors[e][1]).substring(0, 2), 16), i = parseInt(c(this.options.percentColors[e][1]).substring(2, 4), 16), t = parseInt(c(this.options.percentColors[e][1]).substring(4, 6), 16), o.push(this.percentColors[e] = {
                                pct: this.options.percentColors[e][0],
                                color: {
                                    r: a,
                                    g: i,
                                    b: t
                                }
                            });
                            return o
                        }
                    }, e.prototype.set = function(t) {
                        var e, s, n, o, h, r, l, c, p;
                        for (t instanceof Array || (t = [t]), s = n = 0, l = t.length - 1; 0 <= l ? n <= l : n >= l; s = 0 <= l ? ++n : --n) t[s] = this.parseValue(t[s]);
                        if (t.length > this.gp.length)
                            for (s = o = 0, c = t.length - this.gp.length; 0 <= c ? o < c : o > c; s = 0 <= c ? ++o : --o)(e = new a(this)).setOptions(this.options.pointer), this.gp.push(e);
                        else t.length < this.gp.length && (this.gp = this.gp.slice(this.gp.length - t.length));
                        for (s = 0, r = 0, h = t.length; r < h; r++)(p = t[r]) > this.maxValue ? this.options.limitMax ? p = this.maxValue : this.maxValue = p + 1 : p < this.minValue && (this.options.limitMin ? p = this.minValue : this.minValue = p - 1), this.gp[s].value = p, this.gp[s++].setOptions({
                            minValue: this.minValue,
                            maxValue: this.maxValue,
                            angle: this.options.angle
                        });
                        return this.value = Math.max(Math.min(t[t.length - 1], this.maxValue), this.minValue), i.add(this), i.run(this.forceUpdate), this.forceUpdate = !1
                    }, e.prototype.getAngle = function(t) {
                        return (1 + this.options.angle) * Math.PI + (t - this.minValue) / (this.maxValue - this.minValue) * (1 - 2 * this.options.angle) * Math.PI
                    }, e.prototype.getColorForPercentage = function(t, i) {
                        var e, s, n, o, a, h, r;
                        if (0 === t) e = this.percentColors[0].color;
                        else
                            for (e = this.percentColors[this.percentColors.length - 1].color, n = o = 0, h = this.percentColors.length - 1; 0 <= h ? o <= h : o >= h; n = 0 <= h ? ++o : --o)
                                if (t <= this.percentColors[n].pct) {
                                    !0 === i ? (r = this.percentColors[n - 1] || this.percentColors[0], s = this.percentColors[n], a = (t - r.pct) / (s.pct - r.pct), e = {
                                        r: Math.floor(r.color.r * (1 - a) + s.color.r * a),
                                        g: Math.floor(r.color.g * (1 - a) + s.color.g * a),
                                        b: Math.floor(r.color.b * (1 - a) + s.color.b * a)
                                    }) : e = this.percentColors[n].color;
                                    break
                                } return "rgb(" + [e.r, e.g, e.b].join(",") + ")"
                    }, e.prototype.getColorForValue = function(t, i) {
                        var e;
                        return e = (t - this.minValue) / (this.maxValue - this.minValue), this.getColorForPercentage(e, i)
                    }, e.prototype.renderStaticLabels = function(t, i, e, s) {
                        var n, o, a, h, r, l, c, u, d, g;
                        for (this.ctx.save(), this.ctx.translate(i, e), l = /\d+\.?\d?/, r = (n = t.font || "10px Times").match(l)[0], u = n.slice(r.length), o = parseFloat(r) * this.displayScale, this.ctx.font = o + u, this.ctx.fillStyle = t.color || "#000000", this.ctx.textBaseline = "bottom", this.ctx.textAlign = "center", a = 0, h = (c = t.labels).length; a < h; a++) void 0 !== (g = c[a]).label ? (!this.options.limitMin || g >= this.minValue) && (!this.options.limitMax || g <= this.maxValue) && (r = (n = g.font || t.font).match(l)[0], u = n.slice(r.length), o = parseFloat(r) * this.displayScale, this.ctx.font = o + u, d = this.getAngle(g.label) - 3 * Math.PI / 2, this.ctx.rotate(d), this.ctx.fillText(p(g.label, t.fractionDigits), 0, -s - this.lineWidth / 2), this.ctx.rotate(-d)) : (!this.options.limitMin || g >= this.minValue) && (!this.options.limitMax || g <= this.maxValue) && (d = this.getAngle(g) - 3 * Math.PI / 2, this.ctx.rotate(d), this.ctx.fillText(p(g, t.fractionDigits), 0, -s - this.lineWidth / 2), this.ctx.rotate(-d));
                        return this.ctx.restore()
                    }, e.prototype.renderTicks = function(t, i, e, s) {
                        var n, o, a, h, r, l, c, p, u, d, g, m, f, x, v, y, V, w, S, M;
                        if ("object" == typeof t && null !== t && Object.keys(t).length > 0) {
                            for (l = t.divisions || 0, w = t.subDivisions || 0, a = t.divColor || "#fff", x = t.subColor || "#fff", h = t.divLength || .7, y = t.subLength || .2, u = parseFloat(this.maxValue) - parseFloat(this.minValue), d = parseFloat(u) / parseFloat(t.divisions), v = parseFloat(d) / parseFloat(t.subDivisions), n = parseFloat(this.minValue), o = 0 + v, r = (p = u / 400) * (t.divWidth || 1), V = p * (t.subWidth || 1), m = [], S = c = 0, g = l + 1; c < g; S = c += 1) this.ctx.lineWidth = this.lineWidth * h, f = this.lineWidth / 2 * (1 - h), M = this.radius * this.options.radiusScale + f, this.ctx.strokeStyle = a, this.ctx.beginPath(), this.ctx.arc(0, 0, M, this.getAngle(n - r), this.getAngle(n + r), !1), this.ctx.stroke(), o = n + v, n += d, S !== t.divisions && w > 0 ? m.push(function() {
                                var t, i, e;
                                for (e = [], t = 0, i = w - 1; t < i; t += 1) this.ctx.lineWidth = this.lineWidth * y, f = this.lineWidth / 2 * (1 - y), M = this.radius * this.options.radiusScale + f, this.ctx.strokeStyle = x, this.ctx.beginPath(), this.ctx.arc(0, 0, M, this.getAngle(o - V), this.getAngle(o + V), !1), this.ctx.stroke(), e.push(o += v);
                                return e
                            }.call(this)) : m.push(void 0);
                            return m
                        }
                    }, e.prototype.render = function() {
                        var t, i, e, s, n, o, a, h, r, l, c, p, u, d, g, m, f, x;
                        if (f = this.canvas.width / 2, e = this.canvas.height * this.paddingTop + this.availableHeight - (this.radius + this.lineWidth / 2) * this.extraPadding, t = this.getAngle(this.displayedValue), this.textField && this.textField.render(this), this.ctx.lineCap = "butt", l = this.radius * this.options.radiusScale, this.options.staticLabels && this.renderStaticLabels(this.options.staticLabels, f, e, l), this.options.staticZones)
                            for (this.ctx.save(), this.ctx.translate(f, e), this.ctx.lineWidth = this.lineWidth, s = 0, o = (c = this.options.staticZones).length; s < o; s++) r = (x = c[s]).min, this.options.limitMin && r < this.minValue && (r = this.minValue), h = x.max, this.options.limitMax && h > this.maxValue && (h = this.maxValue), m = this.radius * this.options.radiusScale, x.height && (this.ctx.lineWidth = this.lineWidth * x.height, u = this.lineWidth / 2 * (x.offset || 1 - x.height), m = this.radius * this.options.radiusScale + u), this.ctx.strokeStyle = x.strokeStyle, this.ctx.beginPath(), this.ctx.arc(0, 0, m, this.getAngle(r), this.getAngle(h), !1), this.ctx.stroke();
                        else void 0 !== this.options.customFillStyle ? i = this.options.customFillStyle(this) : null !== this.percentColors ? i = this.getColorForValue(this.displayedValue, this.options.generateGradient) : void 0 !== this.options.colorStop ? (0 === this.options.gradientType ? (d = l - this.lineWidth / 2, g = l + this.lineWidth / 2, i = this.ctx.createRadialGradient(f, e, d, f, e, g)) : i = this.ctx.createLinearGradient(0, 0, f, 0), i.addColorStop(0, this.options.colorStart), i.addColorStop(1, this.options.colorStop)) : i = this.options.colorStart, this.ctx.strokeStyle = i, this.ctx.beginPath(), this.ctx.arc(f, e, l, (1 + this.options.angle) * Math.PI, t, !1), this.ctx.lineWidth = this.lineWidth, this.ctx.stroke(), this.ctx.strokeStyle = this.options.strokeColor, this.ctx.beginPath(), this.ctx.arc(f, e, l, t, (2 - this.options.angle) * Math.PI, !1), this.ctx.stroke(), this.ctx.save(), this.ctx.translate(f, e);
                        for (this.options.renderTicks && this.renderTicks(this.options.renderTicks, f, e, l), this.ctx.restore(), this.ctx.translate(f, e), n = 0, a = (p = this.gp).length; n < a; n++) p[n].update(!0);
                        return this.ctx.translate(-f, -e)
                    }, e
                }(s), e = function(t) {
                    function e(t) {
                        this.canvas = t, e.__super__.constructor.call(this), "undefined" != typeof G_vmlCanvasManager && (this.canvas = window.G_vmlCanvasManager.initElement(this.canvas)), this.ctx = this.canvas.getContext("2d"), this.setOptions(), this.render()
                    }
                    return f(e, t), e.prototype.lineWidth = 15, e.prototype.displayedValue = 0, e.prototype.value = 33, e.prototype.maxValue = 80, e.prototype.minValue = 0, e.prototype.options = {
                        lineWidth: .1,
                        colorStart: "#6f6ea0",
                        colorStop: "#c0c0db",
                        strokeColor: "#eeeeee",
                        shadowColor: "#d5d5d5",
                        angle: .35,
                        radiusScale: 1
                    }, e.prototype.getAngle = function(t) {
                        return (1 - this.options.angle) * Math.PI + (t - this.minValue) / (this.maxValue - this.minValue) * (2 + this.options.angle - (1 - this.options.angle)) * Math.PI
                    }, e.prototype.setOptions = function(t) {
                        return null == t && (t = null), e.__super__.setOptions.call(this, t), this.lineWidth = this.canvas.height * this.options.lineWidth, this.radius = this.options.radiusScale * (this.canvas.height / 2 - this.lineWidth / 2), this
                    }, e.prototype.set = function(t) {
                        return this.value = this.parseValue(t), this.value > this.maxValue ? this.options.limitMax ? this.value = this.maxValue : this.maxValue = this.value : this.value < this.minValue && (this.options.limitMin ? this.value = this.minValue : this.minValue = this.value), i.add(this), i.run(this.forceUpdate), this.forceUpdate = !1
                    }, e.prototype.render = function() {
                        var t, i, e, s, n, o;
                        return t = this.getAngle(this.displayedValue), o = this.canvas.width / 2, e = this.canvas.height / 2, this.textField && this.textField.render(this), s = this.radius - this.lineWidth / 2, n = this.radius + this.lineWidth / 2, (i = this.ctx.createRadialGradient(o, e, s, o, e, n)).addColorStop(0, this.options.colorStart), i.addColorStop(1, this.options.colorStop), this.ctx.strokeStyle = this.options.strokeColor, this.ctx.beginPath(), this.ctx.arc(o, e, this.radius, (1 - this.options.angle) * Math.PI, (2 + this.options.angle) * Math.PI, !1), this.ctx.lineWidth = this.lineWidth, this.ctx.lineCap = "round", this.ctx.stroke(), this.ctx.strokeStyle = i, this.ctx.beginPath(), this.ctx.arc(o, e, this.radius, (1 - this.options.angle) * Math.PI, t, !1), this.ctx.stroke()
                    }, e
                }(s), n = function(t) {
                    function i() {
                        return i.__super__.constructor.apply(this, arguments)
                    }
                    return f(i, t), i.prototype.strokeGradient = function(t, i, e, s) {
                        var n;
                        return (n = this.ctx.createRadialGradient(t, i, e, t, i, s)).addColorStop(0, this.options.shadowColor), n.addColorStop(.12, this.options._orgStrokeColor), n.addColorStop(.88, this.options._orgStrokeColor), n.addColorStop(1, this.options.shadowColor), n
                    }, i.prototype.setOptions = function(t) {
                        var e, s, n, o;
                        return null == t && (t = null), i.__super__.setOptions.call(this, t), o = this.canvas.width / 2, e = this.canvas.height / 2, s = this.radius - this.lineWidth / 2, n = this.radius + this.lineWidth / 2, this.options._orgStrokeColor = this.options.strokeColor, this.options.strokeColor = this.strokeGradient(o, e, s, n), this
                    }, i
                }(e), i = {
                    elements: [],
                    animId: null,
                    addAll: function(t) {
                        var e, s, n, o;
                        for (o = [], s = 0, n = t.length; s < n; s++) e = t[s], o.push(i.elements.push(e));
                        return o
                    },
                    add: function(t) {
                        if (x.call(i.elements, t) < 0) return i.elements.push(t)
                    },
                    run: function(t) {
                        var e, s, n, o, a, h, r;
                        if (null == t && (t = !1), isFinite(parseFloat(t)) || !0 === t) {
                            for (e = !0, r = [], n = s = 0, a = (h = i.elements).length; s < a; n = ++s) h[n].update(!0 === t) ? e = !1 : r.push(n);
                            for (o = r.length - 1; o >= 0; o += -1) n = r[o], i.elements.splice(n, 1);
                            return i.animId = e ? null : requestAnimationFrame(i.run)
                        }
                        if (!1 === t) return !0 === i.animId && cancelAnimationFrame(i.animId), i.animId = requestAnimationFrame(i.run)
                    }
                }, "function" == typeof window.define && null != window.define.amd ? define((function() {
                    return {
                        Gauge: o,
                        Donut: n,
                        BaseDonut: e,
                        TextRenderer: h,
                        AnimationUpdater: i
                    }
                })) : "undefined" != typeof module && null != module.exports ? module.exports = {
                    Gauge: o,
                    Donut: n,
                    BaseDonut: e,
                    TextRenderer: h,
                    AnimationUpdater: i
                } : (window.Gauge = o, window.Donut = n, window.BaseDonut = e, window.TextRenderer = h, window.AnimationUpdater = i)
        }).call(this);
        </script>
         <!-- For the BACKEND -->
        <script>
            // src/data/script.js

            const UPDATE_INTERVAL = 3000;
            let lastData = {};

            // --- Tab Handling ---
            function openTab(evt, tabName) {
                let i, tabcontent, tablinks;
                tabcontent = document.getElementsByClassName("tabcontent");
                for (i = 0; i < tabcontent.length; i++) {
                    tabcontent[i].style.display = "none";
                }
                tablinks = document.getElementsByClassName("tablinks");
                for (i = 0; i < tablinks.length; i++) {
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }
                document.getElementById(tabName).style.display = "block";
                if (evt) {
                    evt.currentTarget.className += " active";
                } else {
                    // Find button for default tab activation
                    const defaultTabButton = Array.from(tablinks).find(btn => btn.textContent.trim() === tabName);
                    if (defaultTabButton) defaultTabButton.className += " active";
                }
            }

            // --- Gauge Configuration & Initialization ---
            const baseGaugeOptions = {
                angle: 0.0, lineWidth: 0.3, radiusScale: 0.9,
                pointer: { length: 0.5, strokeWidth: 0.035, color: '#333' },
                limitMax: false, limitMin: false, strokeColor: '#E0E0E0',
                generateGradient: true, highDpiSupport: true,
                renderTicks: { divisions: 5, divWidth: 1.1, divLength: 0.5, divColor: '#666', subDivisions: 3, subLength: 0.3, subWidth: 0.6, subColor: '#aaa' },
                staticLabels: { font: "11px sans-serif", labels: [], color: "#000000", fractionDigits: 0 }
            };

            let gaugeTemp, gaugeHum, gaugeGas, gaugeSoil;

            function createGauge(elementId, minValue, maxValue, zones, labels) {
                const target = document.getElementById(elementId);
                if (!target) { console.error(`Gauge target ${elementId} not found!`); return null; }
                const options = JSON.parse(JSON.stringify(baseGaugeOptions));
                options.staticZones = zones || [];
                options.staticLabels.labels = (labels && labels.length > 0) ? labels : [minValue, maxValue];
                const gauge = new Gauge(target).setOptions(options);
                gauge.minValue = minValue;
                gauge.maxValue = maxValue;
                const valueElement = document.getElementById(elementId + '-val');
                if (valueElement) { gauge.setTextField(valueElement); }
                else { console.error(`Value element ${elementId}-val not found!`); }
                gauge.set(minValue);
                return gauge;
            }

            function initializeGauges() {
                const tempZones = [{ strokeStyle: "#87CEFA", min: 0, max: 15 }, { strokeStyle: "#90EE90", min: 15, max: 25 }, { strokeStyle: "#FFD700", min: 25, max: 35 }, { strokeStyle: "#FFA500", min: 35, max: 45 }, { strokeStyle: "#FF0000", min: 45, max: 50 }];
                const humZones = [{ strokeStyle: "#CD853F", min: 0, max: 30 }, { strokeStyle: "#9ACD32", min: 30, max: 60 }, { strokeStyle: "#87CEEB", min: 60, max: 85 }, { strokeStyle: "#0000CD", min: 85, max: 100 }];
                const gasZones = [{ strokeStyle: "#EAEAEA", min: 0, max: 1000 }, { strokeStyle: "#FFFF00", min: 1000, max: 2500 }, { strokeStyle: "#ADFF2F", min: 2500, max: 4095 }];
                const soilZones = [{ strokeStyle: "#D2B48C", min: 0, max: 30 }, { strokeStyle: "#228B22", min: 30, max: 70 }, { strokeStyle: "#1E90FF", min: 70, max: 100 }];
                const tempLabels = [0, 10, 20, 30, 40, 50];
                const humLabels = [0, 25, 50, 75, 100];
                const gasLabels = [0, 1000, 2000, 3000, 4095];
                const soilLabels = [0, 25, 50, 75, 100];

                gaugeTemp = createGauge('gauge-temp', 0, 50, tempZones, tempLabels);
                gaugeHum = createGauge('gauge-hum', 0, 100, humZones, humLabels);
                gaugeGas = createGauge('gauge-gas', 0, 4095, gasZones, gasLabels);
                gaugeSoil = createGauge('gauge-soil', 0, 100, soilZones, soilLabels);
            }

            function updateGaugeValue(gauge, value) {
                if (gauge && value !== undefined && value !== null && !isNaN(value)) {
                    gauge.set(parseFloat(value));
                } else if (gauge) { gauge.set(gauge.minValue); }
            }

            // --- UI Update Functions ---
            function updateUI(data) {
                // --- Update Gauges ---
                updateGaugeValue(gaugeTemp, data.temp);
                updateGaugeValue(gaugeHum, data.humidity);
                updateGaugeValue(gaugeGas, data.gas);
                updateGaugeValue(gaugeSoil, data.soil);

                // --- Update Status Text & Conditional Timer Tab ---
                let modeText = '--';
                const timerTabButton = document.getElementById('timer-tab-button');

                if (data.mode !== undefined) {
                    const modes = ['AUTO', 'OFF', 'ON', 'HALF', 'TIMER'];
                    modeText = modes[data.mode % 5] || 'Unknown';

                    // Show/Hide Timer Tab based on mode
                    if (timerTabButton) {
                        if (data.mode === 4) { // Mode 4 is TIMER
                            timerTabButton.classList.remove('hidden');
                        } else {
                            timerTabButton.classList.add('hidden');
                            // If the timer tab was active, switch back to dashboard
                            if (document.getElementById('Timer').style.display === 'block') {
                                openTab(null, 'Dashboard'); // Switch without event
                            }
                        }
                    }
                } else {
                    // If mode is unknown, hide timer tab
                    if (timerTabButton) timerTabButton.classList.add('hidden');
                }
                setTextContent('mode', modeText);

                // --- Update Relays ---
                updateRelayStatus('r1', data.relay1);
                updateRelayStatus('r2', data.relay2);
                updateRelayStatus('r3', data.relay3);
                updateRelayStatus('r4', data.relay4);

                // --- Update Settings Display ---
                updateSettingDisplay('min-temp', data.min_temp);
                updateSettingDisplay('max-temp', data.max_temp);
                updateSettingDisplay('delay', data.delay);
                updateSettingDisplay('hum-limit', data.hum_limit);
                updateSettingDisplay('gas-limit', data.gas_limit);

                // --- Update Timer Tab Info (if data is available) ---
                if (data.mode === 4) { // Only update if timer tab *could* be visible
                    setTextContent('timer-current-time', data.currentTimeStr || '--:--:--');
                    setTextContent('timer-start-date', data.startDateStr || '--/--/--');
                    setTextContent('timer-days-passed', data.daysPassed !== undefined ? data.daysPassed : '--');
                    updateTimerTable(data.timerEntries); // Update the schedule table
                }

                // --- Update Navbar IP ---
                setTextContent('nav-ip', data.ip_address ? `IP: ${data.ip_address}` : 'IP: N/A');

                lastData = data; // Store for next comparison
            }
            function updateTimerTable(entries) {
                const tableBody = document.getElementById('timer-list-table')?.querySelector('tbody');
                if (!tableBody) return;
                tableBody.innerHTML = ''; // Clear previous entries

                if (entries && entries.length > 0) {
                    entries.forEach((entry, index) => {
                        const row = tableBody.insertRow();
                        const cellOffset = row.insertCell();
                        const cellMin = row.insertCell();
                        const cellMax = row.insertCell();
                        const cellAction = row.insertCell(); // Action cell

                        cellOffset.textContent = entry.offset !== undefined ? entry.offset : '?';

                        // Min Temp Input
                        const inputMin = document.createElement('input');
                        inputMin.type = 'number';
                        inputMin.className = 'timer-input';
                        inputMin.id = `timer-min-input-${index}`;
                        inputMin.step = 1;
                        // Set value only if NOT currently focused OR if it's the initial empty value
                        if (document.activeElement !== inputMin || inputMin.value === '') {
                            inputMin.value = entry.min !== undefined ? entry.min : '';
                        }
                        cellMin.appendChild(inputMin);

                        // Max Temp Input
                        const inputMax = document.createElement('input');
                        inputMax.type = 'number';
                        inputMax.className = 'timer-input';
                        inputMax.id = `timer-max-input-${index}`;
                        inputMax.step = 1;
                        // Set value only if NOT currently focused OR if it's the initial empty value
                        // if (document.activeElement !== inputMax || inputMax.value === '') {
                        //     inputMax.value = entry.max !== undefined ? entry.max : '';
                        // }
                        inputMax.value = entry.max !== undefined ? entry.max : '';
                        cellMax.appendChild(inputMax);

                        // Reset Button
                        const resetButton = document.createElement('button');
                        resetButton.innerHTML = '<svg width="1em" height="1em" viewBox="0 0 16 16"><use xlink:href="#icon-reset"></use></svg>'; // Reset icon
                        resetButton.title = `Reset Entry ${index + 1} to default (28/32)`;
                        resetButton.onclick = () => resetTimerEntry(index);
                        resetButton.style.marginRight = '5px';
                        resetButton.style.backgroundColor = '#ffc107'; // Warning color
                        resetButton.style.padding = '4px 8px';
                        resetButton.style.fontSize = '0.8em';
                        cellAction.appendChild(resetButton);

                        // Save Button
                        const saveButton = document.createElement('button');
                        saveButton.innerHTML = '<svg width="1em" height="1em" viewBox="0 0 16 16"><use xlink:href="#icon-save"></use></svg>'; // Save icon
                        saveButton.title = `Save Entry ${index + 1}`;
                        saveButton.onclick = () => saveTimerEntry(index);
                        saveButton.style.padding = '4px 8px';
                        saveButton.style.fontSize = '0.8em';
                        cellAction.appendChild(saveButton);
                    });
                } else {
                    const row = tableBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 4; // Ensure colspan is 4
                    cell.textContent = 'No timer schedule entries found.';
                    cell.style.textAlign = 'center';
                }
            }

            // Helper to safely update text content
            function setTextContent(id, text) {
                const el = document.getElementById(id);
                if (el) el.textContent = text;
            }

            function updateSettingDisplay(baseId, value) {
                const dispElement = document.getElementById(baseId + '-disp');
                const inputElement = document.getElementById(baseId + '-input');
                const lastValueKey = baseId.replace('-', '_');
                const lastValue = lastData[lastValueKey];

                // Update display span only if value actually changed
                if (value !== undefined && value !== lastValue) {
                    if (dispElement) dispElement.textContent = value;
                } else if (value === undefined && dispElement) {
                    dispElement.textContent = '--'; // Handle missing data
                }

                // Update input value ONLY IF the input element is NOT the currently active/focused element
                // And only if the value actually changed (avoids resetting cursor position during typing)
                if (inputElement && document.activeElement !== inputElement) {
                    if (value !== undefined && inputElement.value != value) { // Check against current input value too
                        inputElement.value = value;
                    } else if (value === undefined) {
                        inputElement.value = ''; // Clear if data missing
                }
            }
        }

            function updateRelayStatus(elementId, status) {
                const el = document.getElementById(elementId);
                if (el && status !== undefined) {
                    el.textContent = status ? 'ON' : 'OFF';
                    el.className = status ? 'value' : 'value off';
                } else if (el) {
                    el.textContent = '--'; el.className = 'value warn';
                }
            }

            function displayError(message) {
                const errEl = document.getElementById('error-msg');
                if (errEl) {
                    errEl.textContent = message;
                    errEl.style.display = message ? 'block' : 'none';
                    if (message) { setTimeout(() => { displayError(''); }, 5000); }
                }
            }

            // --- Data Fetching and Command Sending ---
            async function fetchStatus() {
                try {
                    const response = await fetch('/status');
                    if (!response.ok) {
                        let errorText = `HTTP error! Status: ${response.status}`;
                        try { errorText = await response.text(); } catch (e) { }
                        throw new Error(errorText);
                    }
                    const data = await response.json();
                    updateUI(data);
                } catch (error) {
                    console.error('Error fetching status:', error);
                }
            }

            async function sendCommand(url) {
                try {
                    displayError(''); // Clear error before sending command
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Command failed: ${response.status} ${errorText}`);
                    }
                    const result = await response.text();
                    console.log('Command result:', result);
                    await fetchStatus(); // Fetch status immediately AFTER command success
                } catch (error) {
                    console.error('Error sending command:', error);
                    displayError(`Command Error: ${error.message}`);
                }
            }

            function setMode() {
                const selectedMode = document.getElementById('mode-select').value;
                sendCommand(`/setmode?mode=${selectedMode}`);
            }

            function saveAllSettings() {
                const minTemp = document.getElementById('min-temp-input').value;
                const maxTemp = document.getElementById('max-temp-input').value;
                const delay = document.getElementById('delay-input').value;
                const humLimit = document.getElementById('hum-limit-input').value;
                const gasLimit = document.getElementById('gas-limit-input').value;

                if (minTemp === '' || maxTemp === '' || delay === '' || humLimit === '' || gasLimit === '') { displayError("Ensure all setting fields have values."); return; }
                const minVal = parseInt(minTemp); const maxVal = parseInt(maxTemp);
                const delayVal = parseInt(delay); const humVal = parseInt(humLimit); const gasVal = parseInt(gasLimit);
                if (isNaN(minVal) || isNaN(maxVal) || isNaN(delayVal) || isNaN(humVal) || isNaN(gasVal)) { displayError("All settings must be valid numbers."); return; }
                if (minVal > maxVal) { displayError("Min Temp cannot be greater than Max Temp."); return; }
                if (delayVal < 1 || delayVal > 300) { displayError("Switch Delay must be between 1 and 300."); return; }
                if (humVal < 0 || humVal > 100) { displayError("Humidity Limit must be between 0 and 100."); return; }
                if (gasVal < 0 || gasVal > 4095) { displayError("Gas Limit must be between 0 and 4095."); return; }

                const queryString = `min=${minVal}&max=${maxVal}&delay=${delayVal}&hum=${humVal}&gas=${gasVal}`;
                sendCommand(`/setsettings?${queryString}`);
            }
            function syncTimeNow() {
                displayError(''); // Clear previous errors
                console.log('Sending command to sync time...');
                sendCommand('/synctime');
                // Optionally provide feedback like "Sync command sent..."
                // Note: Actual time update depends on ESP32 completing NTP sync
                // We will see the updated time on the next /status fetch
            }
            function syncTimeNow() {
                displayError(''); // Clear previous errors
                console.log('Sending command to sync time...');
                sendCommand('/synctime');
            }
            function setTextContent(id, text) {
                const el = document.getElementById(id);
                if (el) el.textContent = text !== null && text !== undefined ? text : '--';
            }

            function updateSettingDisplay(baseId, value) {
                const dispElement = document.getElementById(baseId + '-disp');
                const inputElement = document.getElementById(baseId + '-input');
                const lastValueKey = baseId.replace('-', '_');
                const lastValue = lastData[lastValueKey];
                if (value !== undefined && value !== lastValue) {
                    setTextContent(baseId + '-disp', value);
                    if (inputElement && document.activeElement !== inputElement) {
                        inputElement.value = value;
                    }
                } else if (value === undefined && dispElement) {
                    setTextContent(baseId + '-disp', '--');
                    if (inputElement && document.activeElement !== inputElement) { inputElement.value = '';}
                }
            }
            function saveTimerEntry(index) {
                const minInput = document.getElementById(`timer-min-input-${index}`);
                const maxInput = document.getElementById(`timer-max-input-${index}`);
                if (!minInput || !maxInput) { displayError(`Error finding inputs for timer entry index ${index}`); return; }
                const minValStr = minInput.value; const maxValStr = maxInput.value;
                if (minValStr === '' || maxValStr === '') { displayError(`Entry ${index + 1}: Please enter both Min and Max temps.`); return; }
                const minVal = parseInt(minValStr); const maxVal = parseInt(maxValStr);
                if (isNaN(minVal) || isNaN(maxVal)) { displayError(`Entry ${index + 1}: Min/Max must be valid numbers.`); return; }
                if (minVal > maxVal) {
                    displayError(`Entry <span class="math-inline">\{index \+ 1\}\: Min Temp \(</span>{minVal}) cannot be greater than Max Temp (${maxVal}).`);
                    return; // Stop before sending command
                }
                console.log(`Saving Timer Entry Index: ${index}, Min: ${minVal}, Max: ${maxVal}`);
                sendCommand(`/settimerentry?index=<span class="math-inline">\{index\}&min\=</span>{minVal}&max=${maxVal}`);
            }
            function resetTimerEntry(index) {
                console.log(`Resetting Timer Entry Index: ${index}`);
                // Add confirmation dialog?
                // if (!confirm(`Reset Timer Entry ${index+1} to defaults (28/32)?`)) { return; }
                sendCommand(`/resettimerentry?index=${index}`);
            }
            // --- Initialization ---
            window.onload = () => {
                openTab(null, 'Dashboard'); // Activate Dashboard tab by default
                initializeGauges();
                fetchStatus(); // Initial data fetch
            };
            setInterval(fetchStatus, UPDATE_INTERVAL); // Periodic updates
        </script>
    </body>
</html>